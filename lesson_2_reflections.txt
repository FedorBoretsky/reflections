What happens when you initialize a repository? Why do you need to do it?

	Создается база данных репозитория для текущей папки. Это нужно т.к.
	именно в эту БД все сведения необходимые для работы Git в этой 
	папке.

How is the staging area different from the working directory and the repository?
What value do you think it offers?

	Staging area содержит инофрмацию только о тех файлах, которые были
	добавлены в нее командой add - этим она отличается от working 
	diretcory, которая содержит все файлы.

	Repository помимо файлов содержит разные версии этих файлов 
	и комментарии к каждой версии - этим Repository отличается 
	как от Staging area так и от workind directory.

How can you use the staging area to make sure you have one commit per logical
change?

	Сложно сказать. Я вообще плохо понял необходимость Stage area.
	Но в качестве гипотезы можно выдвинуть следующую концепцию.
	С помощью Stage area программист может сохранять в репозиторий 
	не все файлы изменившиеся файлы, а только те, которые по его
	мнению нужно сохранить в данный Commit.

What are some situations when branches would be helpful in keeping your history
organized? How would branches help?

	Brances могут пригодиться когда я экспериментирую с программой 
	и не знаю заранее насколько удачным будет результат. Я не хочу 
	портить ранее сделанное в моем проекте, поэтому создаю отдельную 
	ветку и эскпериментирую с ней.

	Другой случай – создание промежуточной демо-версии. 
	Часть неработающей функциональности убирается, добавляются 
	пояснения. При этом работа над программой не останавливается,
	поэтому для демо-версии создается отдельная ветвь.

	В случае выбора между несколькими вариантами реализации для
	каждого варианта можно создать отдельную ветку. При необходимости
	доработать тот или иной вариант можно просто переключить в нужную 
	ветку. Когда же будет выбран вариант-победитель, остальные ветки
	можно просто откинуть.

How do the diagrams help you visualize the branch structure?

	На диаграмме видно какие вообще ветви есть в проекте, 
	в какие моменты они возникли. Так же по диаграмме можно 
	определить к какой функциональности есть доступ у каждой ветки,
	а какой функциональности доступа нет потому что ответвление было 
	создано до того как функциональность появилась.

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges
manually?